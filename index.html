
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Continuum</title>
  <meta name="author" content="Kevin Wells">

  
  <meta name="description" content="Game Overview Continuum is a game that explores certain properties of time that we have come
to assume could not be violated. What if, for example, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://wellsie1116.github.com/continuum">
  <link href="/continuum/favicon.png" rel="icon">
  <link href="/continuum/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/continuum/javascripts/modernizr-2.0.js"></script>
  <script src="/continuum/javascripts/ender.js"></script>
  <script src="/continuum/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/continuum/atom.xml" rel="alternate" title="Continuum" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/continuum/">Continuum</a></h1>
  
    <h2>Status updates for my CSSE491 project.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/continuum/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:wellsie1116.github.com/continuum" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/continuum/">Blog</a></li>
  <li><a href="/continuum/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/02/09/user-manual/">User Manual</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-09T11:35:00-05:00" pubdate data-updated="true">Feb 9<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Game Overview</h2>

<p>Continuum is a game that explores certain properties of time that we have come
to assume could not be violated.  What if, for example, you could rewind time,
fixing any mistakes you have made?  What if you were able to jump back in time
and help yourself accomplish something?  Continuum explores these two
questions.</p>

<p><img src="/continuum/images/user-player.png"></p>

<p>This is you.  You are presented with puzzles and you know you must solve them.</p>

<p><img src="/continuum/images/user-links.png"></p>

<p>Buttons can be activated by either pushing cubes onto them or by standing on
them yourself.  Activating buttons do things like open doors.</p>

<p><img src="/continuum/images/user-teleporters.png"></p>

<p>Teleporters are the goal.  Reach a teleporter, and you have solved the level.
This may sound easy, but don&#8217;t worry, bending time doesn&#8217;t come naturally.</p>

<h2>How to Play</h2>

<p>Continuum plays like most First Person Shooters (FPS&#8217;s) with a few
modifications.  It supports your basic movement keys (move with WASD, jump with
SPACE, and use the mouse to look around).  Continuum also introduces some
controls allow the manipulation of time, as outlined below:</p>

<ul>
<li><p>ALT: Holding ALT will enter &#8216;time control&#8217; mode and will initially freeze
time.  From this state, you can use the scroll wheel to either move time
backwards or forwards.  Scroll up to accelerate the rate that time moves
forwards, and scroll down to accelerate the rate that time moves backwards.  To
exit this mode, simply release ALT.</p></li>
<li><p>P: Save a screenshot.  Useful for making blog articles.</p></li>
<li><p>Left click: Set a marker.  The point in time that you specify as a marker will
be the point in time that you can jump back to at a later time.</p></li>
<li><p>Right click: Jump back to marker.  Jumping back to a marker will clone
yourself.  You can watch your clone do what you just did (up until the point
that you jumped back in time), and furthermore, you are free to do anything you
want during this time.  It&#8217;s like teamwork, but you are working with yourself.</p></li>
<li><p>Middle click: Freeze time.  Tap ALT to unfreeze.</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/02/09/technical-notes/">Technical Notes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-09T11:35:00-05:00" pubdate data-updated="true">Feb 9<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Technologies</h2>

<p>Continuum uses various libraries:</p>

<h4>Object-Oriented Graphics Rendering Engine (OGRE)</h4>

<p>OGRE deals with all of the 3D rendering logic that would have been too tedious
to do by hand.  Below is a simple overview of features provided by OGRE (and
were used by Continuum):</p>

<ul>
<li>External material declaration files</li>
<li>External mesh declaration files</li>
<li>Image loader (png, tga, &#8230;)</li>
<li>Direct3D and OpenGL support</li>
<li>Skeletal animation</li>
<li>Tree based scene graph (objects can move relative to a parent)</li>
<li>Full featured particle system</li>
</ul>


<p>By hand, I would have only implemented a small subset of these features.  For
example, I would not have added any particle effects to my teleporter objects,
but because OGRE made it so simple, I was able to add particle effects in only
about an hour of work.  Choosing to go with an existing graphics engine was
critical to the success of this project.</p>

<h4>Open Dynamics Engine (ODE)</h4>

<p>One requirement of this game was to have a physics engine that was both fast and
deterministic.  I experimented with other engines (such as Newton Dynamics), and
while these engines were fast, they would not simulate deterministically.
Because ODE is deterministic, I can save and restore snapshots of the world at
any given time and know that doing so will not inadvertently change the outcome
of the simulation.  Without determinism, whenever the user would be rewinding
time and would hit a snapshot frame, the world would jitter as a result of
errors in the simulation accumulating.  This is not desirable, and ODE does not
suffer from any of these issues.</p>

<h2>Key Concepts</h2>

<h4>Character Rigging</h4>

<p>The rigging for the character camera setup is best explained with a diagram:</p>

<p><img src="/continuum/images/rigging.png"></p>

<p>In this image, the red objects represent logical connections between
components, but do not collide in the physics simulation, whereas the blue
objects are all collision objects.  I have opted to use a simple geometric
primitive for the actual character (a capsule shape) that simply slides along
the ground when given input from the user.  I restrict the angular velocity of
this shape to 0 so the character remains upright during the simulation. Because
the rotation of the capsule is fixed in this way, I need a rigging for the
camera to rotate around.  In the diagram, the red sphere is a hinge joint that
allows the camera to freely rotate around the capsule (while the camera always
tracks the character).  When the player moves the mouse left or right, I simply
apply a force to either side of the camera to push it in the correct location.
To look up or down, the camera can move up and down the vertical red line (with
a little bit of an arc), always tracking the top of the capsule.</p>

<p>This might seem like an overcomplicated setup, but it provides a number of
benefits.  Mainly, I never have to worry about the camera entering objects and
obscuring the view of the player because it is an actual object in the physics
simulation.  Doing this math myself would be infeasible.</p>

<h4>Links</h4>

<p>One design goal I had with Continuum was that I wanted to separate the design of
the levels from the implementation of the game itself.  This means that if a
user needs to interact with some other part of the level or with the game as a
whole, that interaction must be specified in the level itself, not be statically
coded in the game.  To accomplish this goal, I introduced a concept of link
sources and sinks.  The main idea behind links is that any object in the map can
be designated as a link source or sink.  Every source and sink are also assigned
to a specific link channel (so that multiple linked pairs can exist
simultaneously).  If the user (or another moveable physics object) comes in
contact with a link source, any corresponding link sinks will be activated.
This allows the user to do things such as open doors or start an elevator in
response to pressing a button.</p>

<p>A similar concept I added was teleporters.  Teleporters function similarly to
link sources, except that, when activated, they teleport the user to a new
level.</p>

<h4>Rewinding Time</h4>

<p>One of the key gameplay elements of Continuum is the ability to manipulate the
flow of time.  More specifically, the player can:</p>

<ul>
<li>Play time backwards</li>
<li>Play time forwards (while replaying past input events)</li>
<li>Set a marker in time</li>
<li>Jump back that marker, forking the player into 2 instances</li>
</ul>


<p>These features require a framework that is aware of the entire state of the
world at more than a single time instance (which is very untypical of video
games to have to track).  Continuum accomplishes this by utilizing two main
strategies: taking snapshots of the game state and recording all user input.</p>

<p>Every 100 frames, the game iterates over every object in the world (cubes,
models, player, etc&#8230;) and records various attributes (position, orientation,
linear velocity, angular velocity, and any custom data specified by that
object).  With this information, the game, if requested, can compute any state
in between snapshots by restoring the state of the game to an earlier snapshot
and replaying the game until the appropriate timestep is reached.  This
save/restore/replay operation happens fast enough that it is not noticeable when
the player is performing actions such as rewinding time.</p>

<p>Unfortunately, simply capturing the states of objects at various timesteps is
not enough information to completely resimulate the world.  The game also needs
to track all user input provided by the user.  This information becomes
especially useful when forking time.  When the user forks time, the game copies
all input that the user made from the marker to the end of the simulation and
duplicates the player entity.  Every frame, instead of piping any user input to
the cloned entity, it simply replays input that was originally provided by the
player, allowing the player to be free to control the other entity.</p>

<h2>Level Design</h2>

<p>Levels can be designed and built using the free modeling program:
<a href="http://www.blender.org">Blender</a> in conjunction with a custom export script
that is used to convert Blender scenes to scenes that can be imported by
Continuum. All paths listed are relative to the root of the repository.</p>

<h4>Prerequisites</h4>

<ul>
<li><p>A Linux environment</p></li>
<li><p>The newest version of Blender (2.61)</p></li>
<li><p>Experience using Blender</p></li>
</ul>


<h4>Setting Up the Environment</h4>

<p>Run the script located at blender/scripts/mklinks.sh.  This will copy the
Blender export script to the necessary location in your Blender installation.
Next, run Blender and enable the OGRE dotScene exporter addon.</p>

<h4>Making Levels</h4>

<p>Now for the fun part, designing levels.  You can build scenes like you normally
would with a few exceptions, outlined below:</p>

<ul>
<li><p>Rotation and scale for objects are not preserved.  Instead, apply the
transformations to the mesh.</p></li>
<li><p>The camera must be facing down.  This is due to a bug with the export script
that orients the camera incorrectly.  The game will reorient the camera
appropriately.</p></li>
<li><p>Levels can be called whatever you want, but the game will always look for a
level entitled &#8220;menu&#8221; when it first loads.</p></li>
</ul>


<h4>Object Properties</h4>

<p>Various properties can be applied to objects to change how they interact with
the game.  By default, every mesh is given a bounding box and placed in the
physics world as an immovable object. This is not always desirable.
Furthermore, graphical effects and level transitions can be added by adding
custom properties.</p>

<ul>
<li><p>Physics: no.  Disable all physics integration.  The object will be drawn, but
will collide with nothing.</p></li>
<li><p>Physics: Cube.  Create a cube that can be moved around the scene and can
activate links.</p></li>
<li><p>Mass: <em>n</em>.  Set the mass of a moveable physics object to <em>n</em>.</p></li>
<li><p>LinkSource: <em>n</em>.  Define this object to activate link <em>n</em>.</p></li>
<li><p>LinkSink: <em>n</em>.  Define this object to be activated by link <em>n</em>.  Upon
activation, the animation entitled &#8220;Activate&#8221; will be played for the given
object.  During the animation, the bounding box will be updated appropriately.
This makes it possible to make things like doors that open in response to the
Activate animation.</p></li>
<li><p>Teleport: <em>level</em>.  When touched by a player, teleport to <em>level</em>.</p></li>
<li><p>Particles1: <em>name</em>.  Add a particle effect to the given object.</p></li>
<li><p>Particles2: <em>name</em>.  Add a particle effect to the given object.</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/02/08/forking-time/">Forking Time</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-08T21:09:00-05:00" pubdate data-updated="true">Feb 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Commit log</h2>

<p>As expected, I have not been able to work on this project as much as I would
have liked to this week, but I was still able to implement the ability to fork
time.  With this new ability, levels that were impossible can now be solved.</p>

<p><img src="/continuum/images/forking.png"></p>

<pre><code>Commits:
Animate ghost mesh +.5h
Allow time to rewind past a fork +.5h
Implement most of forking time +1.5h
Allow basic jumping back to a marker +.75h
Replay user input when playing time forwards +1h
Allow Player controller to be rewound +3h

Total: 7.25
</code></pre>

<p>For the remainder of the quarter, I would like to add a few more levels and will
write the user/designer documentation so that people can make levels for the
game (and play them) in the future.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/02/01/real-gameplay/">Real Gameplay</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-01T20:14:00-05:00" pubdate data-updated="true">Feb 1<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Commit log</h2>

<p>This week was a mix of work, ranging from making buttons doing something to
adding teleporters from one level to another.  The game is at this point
playable (although without forking time, level 2 is not beatable).  That is the
goal for next week.</p>

<p><img src="/continuum/images/teleporters.png"></p>

<pre><code>Commits:
Add level 2 +.5h
Add teleportation nodes to other levels +2.25h
Add particles support. +1.25h
Add animation for walking +.5h
Adjust character height and camera tracking +1.25h
Tweak robot mesh +.25h
Add link (source/sink) support.  +4h
Add models/animations. +3.75h

Total: 13.75
</code></pre>

<h2>Reviewing Feature Listing</h2>

<p>A few weeks ago, I outlined various features that I wanted to be included in
final game.  This week, I took a bit to review where I am relative to that list:</p>

<ul>
<li><p>Character movement/interaction</p>

<p>With the addition of links (sources and sinks), the character can now
actually interact with the environment.  I would also like to allow the
character to pickup objects, but that functionality is not absolutely necessary
to make the game playable.  Given time, I would like to add that last feature to
character movement.</p></li>
<li><p>Models</p>

<p>I have all of the models that I need for the game.</p></li>
<li><p>Forking time</p>

<p>Not yet functional.  I record the user&#8217;s input, and it should not be too
hard to make the transition to showing a second character, but I will need at
least a week to fully implement this feature.</p></li>
<li><p>Level design</p>

<p>I am making levels as I implement features that utilize them, but I will not
be able to make nearly enough levels to make this a full featured game.
Instead, I am making the levels easy to create with Blender so that people can
make their own levels.</p></li>
<li><p>Audio system</p>

<p>I do not think I will have time to implement this, even though it would have
been fun to hear the audio play backwards while rewinding time.</p></li>
<li><p>Main menu</p>

<p>Implemented this week via teleporters.  Objects in the level editor can be
defined to teleport the player to another level when the player touches that
object.</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/01/26/shadows-and-models/">Shadows and Models</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-26T13:44:00-05:00" pubdate data-updated="true">Jan 26<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In response to comments from last week, I spent some time adding shadows to the
scene.  Fortunately, OGRE provides this functionality mostly automatically, and
I only needed to specify which objects should receive and/or cast shadows.
After debugging a particularly obscure issues with having my own models (as
opposed to OGRE&#8217;s built in models) be able to cast shadows, I was able to get
the visual effect close enough to what I want without as much of a performance
hit as I expected.  Stencil buffer shadows look very realistic, but they are
computationally expensive, and while the game was running at around 400FPS, it
has degraded to about 90FPS.  This may become an issue with larger scenes, but
OGRE also supports texture based shadows, and I may need to explore that at a
later time.</p>

<p>I also imported more models to utilize during game play.  Included in the
screenshot below is a button that is activated when a cube or the player is
placed upon it. I will use buttons to perform various actions in the levels,
such as opening and closing doors.</p>

<p><img src="/continuum/images/shadows.png"></p>

<h2>Commit log</h2>

<pre><code>Commits:
Add models to test scene. Design levels.  +4.5h
Fix character movement issue +.25h
Tweak character parameters +.25h
Add shadows to all objects in the scene +1.75h
Update models, add textures. +4h
Work on replaying input events +.25h
Record input events +.5h

Total: 11.5
</code></pre>

<h2>Looking Ahead</h2>

<p>This next week, I need to finalize some level designs and work out the
transitions between levels.  I also need to link together objects in the scene,
so that pressing a button actually does something.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/01/19/adding-a-character/">Adding a Character</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-19T09:46:00-05:00" pubdate data-updated="true">Jan 19<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>My focus for this week was making the player more than just a free flying
camera.  I have designed a way to have the character interact with the
environment and control a third person camera.  I have also taken some time to
extract and make some models and textures for the game.</p>

<h2>Rigging</h2>

<p>My camera setup is best explained with a diagram.</p>

<p><img src="/continuum/images/rigging.png"></p>

<p>In this image, the red objects represent logical connections between components,
but do not collide in the physics simulation, whereas the blue objects all
are collision objects.  I have opted to use a simple geometric primitive for the
actual character (a capsule shape) that simply slides along the ground when
given input from the user.  I disallow this shape from ever rotating, so the
character remains upright during the simulation. Because the rotation of the
capsule is fixed, I need a rigging for the camera to rotate around.  In the
diagram, the red sphere is a hinge joint that allows the camera to freely
rotate around the capsule.  When the player moves the mouse left or right, I
simply apply a force to either side of the camera to push it in the correct
location.  To look up or down, the camera can move up and down the vertical red
line, always tracking the top of the capsule.</p>

<p>This might seem like an overcomplicated setup, but it provides a number of
benefits.  Mainly, I never have to worry about the camera entering objects and
obscuring the view of the player because it is an actual object in the physics
simulation.  Doing this math myself would be infeasible.  In the future, I will
use the physics information to provide the necessary animations for the
character.  Also, because I am already recording the states of all physics
objects, rewinding time also rewinds the camera and player location.</p>

<h2>Models</h2>

<p>I had hoped it would be easy to extract models from an existing video game to
use in this game.  While I was able to obtain every model I wanted, I could not
obtain many animations or the texture mappings to most of the models.  As a
result, I have decided to use one of OGRE&#8217;s built in character models, since
that model provides animations I need to make the character look like it is
actually interacting with the world.  This is one thing I would like to focus on
during this next week.</p>

<h2>Time Logging</h2>

<p>I have also started appending time costs to my commit messages so that I can get
a better sense of how much time I am spending on the project.  I have included a
log from the past week below:</p>

<pre><code>Commits:
Add input recorder (not yet utilized) +2h
Restore previous rewinding functionality +1h
Proxy physics world through World +1h
Add some basic textures and player model +6h
Improve character movement and damping +1h
Add time reporting functionality +.25h
Change camera pitch tracking +.25h
Add some damping for player velocity +.5h
Add vector library.  (time for missed log) +3h
Add character jumping. +.5h

Total: 15.50
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/01/08/todo-list/">Todo List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-08T20:56:00-05:00" pubdate data-updated="true">Jan 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Up to this point, I have simply been working on whatever I felt I needed to do
in the order I felt I needed to do it.  While this works for projects without
set requirements or a set due date, this project has a certain set of
functionality requirements, and it is due at the end of the quarter, which is
why I have taken some time this week to determine what I would like to have in
the final game and how long I expect each of those features to take (based on my
current rate of progress).</p>

<h2>Feature Listing</h2>

<ul>
<li><p>Character movement/interaction (1 week)</p>

<p>Because I am using a physics simulation for the world, I need to integrate
the character into that simulation in order for the character to interact with
the world.  Furthermore, I want the camera to be 3rd person, so I need to
introduce a 3D model of the character and animate that model.</p></li>
<li><p>Models (1 week)</p>

<p>I am not a graphic designer, and I don&#8217;t want to pretend to be.  I plan on
&#8216;borrowing&#8217; models from an existing game, but I am unsure to the process (other
than I know it is possible).  It will be useful to have a determined set of
models before attempting to design levels, in case the models are different
proportions than I expect.</p></li>
<li><p>Forking time (1 week)</p>

<p>I can currently rewind time, but that always keeps the same number of
objects in the simulation.  Forking time will require introducing new objects
into the scene and contains a good number of unknowns that I have not yet
explored.</p></li>
<li><p>Level design (1 week)</p>

<p>The component that will absolutely determine this game&#8217;s success is the
quality of its levels.  I need a good chunk of time to design and build the
levels.</p></li>
<li><p>Audio system (1 week)</p>

<p>One of the more fun aspects of this game.  I want to have ambient sound
effects and music (as most games do), except I want the audio react to how the
user is manipulating time.  For example, if the user rewinds time at 2x, the
audio will backwards at 2x.  I know OpenAL provides this functionality, but I
have never actually used the library before.</p></li>
<li><p>Main menu (.5 week)
A minor feature, but it is nice to not immediately be thrown into the game
after launching it.  It would also be nice to track the user&#8217;s progress and let
them save and load games.</p></li>
</ul>


<p>There are plenty of other things that I would <strong>like</strong> to do but don&#8217;t think I
will have time to do.  Examples include, but are not limited to: Python
integration, S-3D rendering, and space manipulation (via portals).</p>

<h2>Making more time</h2>

<p>Quickly adding up my time estimates, I come up with 5.5 weeks.  Well there are
5.5 weeks left in the quarter, so this should be no problem to finish on time,
right?  I would like to answer &#8220;yes&#8221;, but I know from past experience that I
tend to underestimate my time requirements, overestimate my free time, and do
not foresee all of the problems that I will face.  I typically like to include a
20% time buffer to account for those unknowns, and this current setup does not
provide that.  Still, I based these time estimates on my current work load.  I
have been prioritizing Senior Project over this project during the quarter, and
I think it is a good time to switch priorities since our Senior Project is ahead
of schedule.  With this change, I believe that I can finish this project by the
end of 10th week, but I do not want to discard the possibility that it will take
longer.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2012/01/05/running-backwards/">Running Backwards</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-05T10:00:00-05:00" pubdate data-updated="true">Jan 5<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>A Physics Engine</h2>

<p>Most gaming oriented physics engines focus on one major goal: speed.  If a
physics simulation takes too long, then the physics world can&#8217;t be updated in
real-time and the whole point of having a physics engine in the game is lost.
Unfortunately, physics engines optimizing for speed can have some drawbacks.</p>

<h3>First Attempt</h3>

<p>Initially, I attempted to use <a href="http://newtondynamics.com/">Newton Dynamics</a> for
my physics engine.  It had nearly all of the features I needed and ran fast as
well.  When I implemented snapshot states of the world, however, the simulation
would output a different result whenever I would jump back in time.  Given that
my simulation has to be deterministic, this engine would not work as is.  After
much tweaking and prodding, I found why the engine would produce
nondeterministic results.  For efficiency, the engine would cache <em>contact
joints</em> from the previous time step to make the computations for the next time
step a bit more efficient.  When I make my snapshots of the physics world, I can
copy all of the information about those contact joints, but I cannot restore
them when I want to jump back to a specific time.  I could simply remove the old
contact joints every frame, but the engine strongly advises
<a href="http://www.newtondynamics.com/wiki/index.php5?title=NewtonInvalidateCache">NOT</a>
to do that.</p>

<h3>Open Dynamics Engine</h3>

<p>Unwilling to cause a significant performance hit to my simulation just to get
deterministic results, I decided to switch engines hoping that the next one I
tried would work better.  I have used <a href="http://ode.org/">ODE</a> in the past and it
worked well, so I thought I would try it.  After switching out the physics
simulation code, I ran the game to find that things still did not run
deterministically.  I was sure that I was capturing all relevant information
from the physics bodies (position, orientation, linear velocity, and angular
velocity).  Force is applied every <em>frame</em>, so that is not a piece of
information that I need to capture.  Again, after a bit of prodding, I found
that ODE uses a random number generator in its simulation.  Fortunately, the
generator allows me to capture and restore its current <em>seed</em>.  I also had to
change how I stored the objects&#8217; orientation.  I initially used a quaternion,
but apparently the engine stores it in matrix form, and the few decimal places
that were lost in the conversions caused the simulation to veer off course.
After making those modifications, I can now simulate a world deterministically,
jumping back in time arbitrarily, and see the same simulation (or a different
one, if I influence the world differently.</p>

<h2>Storing World Snapshots</h2>

<p>After being able to store the world snapshots, I needed a data structure that
can store multiple, ordered snapshots and help with determining how and when to
generate additional snapshots.  While I have not yet fully implemented the
structure, I have identified the main operations I need to perform with it:</p>

<div><script src='https://gist.github.com/1565882.js?file='></script>
<noscript><pre><code>/**
 * Adds a state the ordered set of world states
 * 
 * Preferred structure: Tree
 */
void add(WorldSnapshot* state);

/**
 * Checks if the structure contains a snapshot at the given timestep.
 * 
 * Preferred structure: Tree or Hashtable
 */
bool contains(int timestep);

/**
 * Deletes all snapshots after the given timestep
 * 
 * Preferred structure: Array or List
 */
void purgeAfter(int timestep);

/**
 * Returns the snapshot with a timestep equal
 * to or before the given timestep
 * 
 * Preferred structure: Tree
 */
WorldSnapshot* getClosest(int timestep);

/**
 * Removes all unnecessary snaphots from the structure
 * 
 * Preferred structure: List
 */
void prune(int timestep);
</code></pre></noscript></div>


<p>As you can see by the <strong>Preferred structure</strong> comment, no simple data structure
exists that can efficiently perform all of these operations.  Currently,
however, I only need to use <em>add</em>, <em>purgeAfter</em>, and <em>getClosest</em>, so I have
implemented the structure as a linked list (Dequeue) until I need the additional
functionality.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2011/12/16/a-real-framework/">A Real Framework</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-16T09:54:00-05:00" pubdate data-updated="true">Dec 16<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Two weeks ago, my goal was to finish the basics of my own game framework so I
could get to the fun part of the project: actually making the game.  As I got
into all that I needed to implement before I would be able to get to the actual
game making part, I found the workload a bit overwhelming.  I enjoy using
OpenGL, and using it gives an enormous amount of flexibility, but I could not
justify taking 2-3 times as long using it than using some framework that has
already taken care of all of the technical backend stuff. Enter
<a href="http://www.ogre3d.org">OGRE</a>, an open-source cross-platform rendering engine.</p>

<h2>OGRE</h2>

<p>OGRE is a rendering engine that is independent of any rendering backend.  It can
certainly use OpenGL, but it can just as well use DirectX to render my scenes.
The point is, I only need to setup the scene using meshes, cameras, lights, and
a few other elements, and OGRE does everything that is needed to actually render
the scene.  This greatly simplifies the work that I need to do.  Instead of
figuring out how to store, load, and render my models, OGRE already has the
functionality to do that.  All I have to do is make the models and move them
throughout the world (aka Physics) in a meaningful way.  Furthermore, OGRE has a
library that allows me to define the entire scene (or level) in an external
resource, and the entire scene can be constructed automatically.  This means
that I can use existing programs to generate my levels. For that task, enter
<a href="http://www.blender.org">Blender</a>.</p>

<h2>Blender</h2>

<p>If you have done any 3D modeling in the past, you have probably heard of
Blender because that is exactly what it does.  Why use Blender to design my
levels?  Well, it is free and OGRE has a scene exporter to the level format that
my game will load.  I have also used Blender for level design in the past, so I
am already familiar with it.</p>

<p>After designing my levels, I can simply export them (the level format, the
meshes, and any materials) to the format that my game can understand.  While
loading the level, I create any physics entities that are needed, and kickoff
the physics simulation.</p>

<h2>Looking Forward</h2>

<p>From this point, I have a good list of things that need done.  I need models to
work with, I need some notion of a character that can walk through the levels
and interact with the level, and I need to start implementing the actual point
of the game: messing with time.  For the next few weeks, I will be focusing on
the last two.</p>

<p>Physics engines typically do not allow stepping time backwards, but that is a
problem that I can somewhat easily solve.  If I can track all of the user&#8217;s
input into the game, I can essentially <em>replay</em> the entire scene from start to
finish, simply simulating the input from the user.  This means that no matter
what timestep the world is at, I can compute the state of the world at a earlier
timestep.  Of course, it would be horribly slow to always compute this from the
beginning of the level, so I will have to take snapshots of the world at various
timesteps.  After implementing these concepts, I will be able to completely
control the flow of time in the game.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/continuum/blog/2011/11/30/getting-things-started/">Getting Things Started</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-30T22:45:00-05:00" pubdate data-updated="true">Nov 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Game Overview</h2>

<p>My tentative plan for the game is to combine elements from both
<a href="http://braid-game.com">Braid</a> and <a href="http://www.thinkwithportals.com">Portal</a>
with some new game play ideas I come up with.  My main goal with this game is
to explore how a game could bend the ideas of time and space (space-time
<strong>continuum</strong>) to create a unique and innovative game play experience.</p>

<h3>Breaking Time</h3>

<p>At its heart, Continuum will be a puzzle game where the player is presented with
a 3 dimensional world where they need to navigate to the exit.  In order to
reach their goal, they will need to utilize various abilities that they acquire
throughout the game (related to manipulating time and space).  Players will have
no time limit and will have only 1 life, but even though the game will have
elements deadly to players, they will only need 1 life because the players will
have the ability to rewind time.  Even if a player dies, they can simply rewind
time to a state where they were still alive, hopefully making better choices in
the future.  For someone that has not played games such as Braid in the past,
this concept can seem a bit odd.  Consider the following timeline:</p>

<pre><code>            :----------&gt;-------&gt;
            :     0.5     1.0
            :-------:
              -1.0  :
local  -------------:
         1.0

global ------------------------------------------------------------------&gt;
       1    3       2 4        5
</code></pre>

<p>In this graph, <em>global</em> is time as it passes for a passive observer, whereas
<em>local</em> is time as it passes for the player, where they have the ability to
control the flow of time.  In this example, the player plays from timestep 1 to
2, where the player hits an obstacle and dies.  They then rewind time back to
timestep 3, where they continue playing at half of the normal rate of time.
After crossing the difficult obstacle (at timestep 4), they continue playing
until timestep 5, where they solve the puzzle.  To someone watching the game,
the would not see the progression from timestep 2 to 3.  A passive observer
would only see the following sequences of timesteps: 1, 3, 4, 5.</p>

<p>Players will gain additional time manipulation abilities throughout the game.
Consider the following timeline:</p>

<pre><code>                    :----------X
                    :
local  -------------:              :---------X
                    :              :
                    :--------------:
                                   :
                                   :-----------------&gt;

global ------------------------------------------------------------------&gt;
       1            2          3   4         5       6
</code></pre>

<p>In this example, the player has the ability to &#8216;fork&#8217; time, the ability to
duplicate themselves and control both timelines.  How is this useful?  Consider
a simple example.  In a level, there is a door which must be opened by a switch
that it takes 5 seconds to walk to.  The switch, however, will only keep the
door open for 3 seconds.  To solve the puzzle, the player can set a marker point
(timesteps 2 and 4 in the example above), go and press the button, and then jump
back to the marker point, and simply walk through the door when their double
presses the button.</p>

<p>In the example above, the player moves through time normally from step 1 to 2,
at which point they set a fork marker.  They then move through the top branch to
step 3, where they instantaneously jump back to step 2 and then move through the
lower branch to step 4.  During this time, they could see their &#8216;double&#8217; moving
through the level doing whatever they did.  This example has a second fork in
time, and it functions the same as the first.</p>

<h3>Breaking Space</h3>

<p>Time permitting, I would like to also incorporate space manipulation elements
similar to the popular game Portal, which involves the player specifying two
arbitrary points in the level that they can instantaneously jump from one point
to the other.  I plan on basing the game in the same universe as Portal, and it
would be fun to incorporate aspects of other games in that universe.</p>

<h2>Choosing a Framework</h2>

<p>While the focus of this project is on creating a full featured game, I feel like
I will be unable to use any existing full-package frameworks to do the job
mostly because this game breaks conventional ideas about first person shooters.
Most game engines don&#8217;t support forking time, let alone introducing portals.
One game engine that I did look into was Source, the same game engine that was
used to make Portal and Portal 2.  It is possible to write mods for those games,
but, unfortunately, Valve has not yet released the SDK for Portal 2, which is my
target platform if I would make a mod to the game.  Instead, I plan on using SDL
to host the application, OpenGL for graphics rendering, OpenAL for 3D audio, ODE
for my physics engine, and a blend of C and Python for the implementation language.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/continuum/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/continuum/blog/2012/02/09/user-manual/">User Manual</a>
      </li>
    
      <li class="post">
        <a href="/continuum/blog/2012/02/09/technical-notes/">Technical Notes</a>
      </li>
    
      <li class="post">
        <a href="/continuum/blog/2012/02/08/forking-time/">Forking Time</a>
      </li>
    
      <li class="post">
        <a href="/continuum/blog/2012/02/01/real-gameplay/">Real Gameplay</a>
      </li>
    
      <li class="post">
        <a href="/continuum/blog/2012/01/26/shadows-and-models/">Shadows and Models</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Kevin Wells -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
