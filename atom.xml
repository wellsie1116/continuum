<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Continuum]]></title>
  <link href="http://wellsie1116.github.com/continuum/atom.xml" rel="self"/>
  <link href="http://wellsie1116.github.com/continuum/"/>
  <updated>2012-01-12T10:31:39-05:00</updated>
  <id>http://wellsie1116.github.com/continuum/</id>
  <author>
    <name><![CDATA[Kevin Wells]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[todo list]]></title>
    <link href="http://wellsie1116.github.com/continuum/blog/2012/01/08/todo-list/"/>
    <updated>2012-01-08T20:56:00-05:00</updated>
    <id>http://wellsie1116.github.com/continuum/blog/2012/01/08/todo-list</id>
    <content type="html"><![CDATA[<p>Up to this point, I have simply been working on whatever I felt I needed to do
in the order I felt I needed to do it.  While this works for projects without
set requirements or a set due date, this project has a certain set of
functionality requirements, and it is due at the end of the quarter, which is
why I have taken some time this week to determine what I would like to have in
the final game and how long I expect each of those features to take (based on my
current rate of progress).</p>

<h2>Feature Listing</h2>

<ul>
<li><p>Character movement/interaction (1 week)</p>

<p>Because I am using a physics simulation for the world, I need to integrate
the character into that simulation in order for the character to interact with
the world.  Furthermore, I want the camera to be 3rd person, so I need to
introduce a 3D model of the character and animate that model.</p></li>
<li><p>Models (1 week)</p>

<p>I am not a graphic designer, and I don&#8217;t want to pretend to be.  I plan on
&#8216;borrowing&#8217; models from an existing game, but I am unsure to the process (other
than I know it is possible).  It will be useful to have a determined set of
models before attempting to design levels, in case the models are different
proportions than I expect.</p></li>
<li><p>Forking time (1 week)</p>

<p>I can currently rewind time, but that always keeps the same number of
objects in the simulation.  Forking time will require introducing new objects
into the scene and contains a good number of unknowns that I have not yet
explored.</p></li>
<li><p>Level design (1 week)</p>

<p>The component that will absolutely determine this game&#8217;s success is the
quality of its levels.  I need a good chunk of time to design and build the
levels.</p></li>
<li><p>Audio system (1 week)</p>

<p>One of the more fun aspects of this game.  I want to have ambient sound
effects and music (as most games do), except I want the audio react to how the
user is manipulating time.  For example, if the user rewinds time at 2x, the
audio will backwards at 2x.  I know OpenAL provides this functionality, but I
have never actually used the library before.</p></li>
<li><p>Main menu (.5 week)
A minor feature, but it is nice to not immediately be thrown into the game
after launching it.  It would also be nice to track the user&#8217;s progress and let
them save and load games.</p></li>
</ul>


<p>There are plenty of other things that I would <strong>like</strong> to do but don&#8217;t think I
will have time to do.  Examples include, but are not limited to: Python
integration, S-3D rendering, and space manipulation (via portals).</p>

<h2>Making more time</h2>

<p>Quickly adding up my time estimates, I come up with 5.5 weeks.  Well there are
5.5 weeks left in the quarter, so this should be no problem to finish on time,
right?  I would like to answer &#8220;yes&#8221;, but I know from past experience that I
tend to underestimate my time requirements, overestimate my free time, and do
not foresee all of the problems that I will face.  I typically like to include a
20% time buffer to account for those unknowns, and this current setup does not
provide that.  Still, I based these time estimates on my current work load.  I
have been prioritizing Senior Project over this project during the quarter, and
I think it is a good time to switch priorities since our Senior Project is ahead
of schedule.  With this change, I believe that I can finish this project by the
end of 10th week, but I do not want to discard the possibility that it will take
longer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Backwards]]></title>
    <link href="http://wellsie1116.github.com/continuum/blog/2012/01/05/running-backwards/"/>
    <updated>2012-01-05T10:00:00-05:00</updated>
    <id>http://wellsie1116.github.com/continuum/blog/2012/01/05/running-backwards</id>
    <content type="html"><![CDATA[<h2>A Physics Engine</h2>

<p>Most gaming oriented physics engines focus on one major goal: speed.  If a
physics simulation takes too long, then the physics world can&#8217;t be updated in
real-time and the whole point of having a physics engine in the game is lost.
Unfortunately, physics engines optimizing for speed can have some drawbacks.</p>

<h3>First Attempt</h3>

<p>Initially, I attempted to use <a href="http://newtondynamics.com/">Newton Dynamics</a> for
my physics engine.  It had nearly all of the features I needed and ran fast as
well.  When I implemented snapshot states of the world, however, the simulation
would output a different result whenever I would jump back in time.  Given that
my simulation has to be deterministic, this engine would not work as is.  After
much tweaking and prodding, I found why the engine would produce
nondeterministic results.  For efficiency, the engine would cache <em>contact
joints</em> from the previous time step to make the computations for the next time
step a bit more efficient.  When I make my snapshots of the physics world, I can
copy all of the information about those contact joints, but I cannot restore
them when I want to jump back to a specific time.  I could simply remove the old
contact joints every frame, but the engine strongly advises
<a href="http://www.newtondynamics.com/wiki/index.php5?title=NewtonInvalidateCache">NOT</a>
to do that.</p>

<h3>Open Dynamics Engine</h3>

<p>Unwilling to cause a significant performance hit to my simulation just to get
deterministic results, I decided to switch engines hoping that the next one I
tried would work better.  I have used <a href="http://ode.org/">ODE</a> in the past and it
worked well, so I thought I would try it.  After switching out the physics
simulation code, I ran the game to find that things still did not run
deterministically.  I was sure that I was capturing all relevant information
from the physics bodies (position, orientation, linear velocity, and angular
velocity).  Force is applied every <em>frame</em>, so that is not a piece of
information that I need to capture.  Again, after a bit of prodding, I found
that ODE uses a random number generator in its simulation.  Fortunately, the
generator allows me to capture and restore its current <em>seed</em>.  I also had to
change how I stored the objects&#8217; orientation.  I initially used a quaternion,
but apparently the engine stores it in matrix form, and the few decimal places
that were lost in the conversions caused the simulation to veer off course.
After making those modifications, I can now simulate a world deterministically,
jumping back in time arbitrarily, and see the same simulation (or a different
one, if I influence the world differently.</p>

<h2>Storing World Snapshots</h2>

<p>After being able to store the world snapshots, I needed a data structure that
can store multiple, ordered snapshots and help with determining how and when to
generate additional snapshots.  While I have not yet fully implemented the
structure, I have identified the main operations I need to perform with it:</p>

<div><script src='https://gist.github.com/1565882.js?file='></script>
<noscript><pre><code>/**
 * Adds a state the ordered set of world states
 * 
 * Preferred structure: Tree
 */
void add(WorldSnapshot* state);

/**
 * Checks if the structure contains a snapshot at the given timestep.
 * 
 * Preferred structure: Tree or Hashtable
 */
bool contains(int timestep);

/**
 * Deletes all snapshots after the given timestep
 * 
 * Preferred structure: Array or List
 */
void purgeAfter(int timestep);

/**
 * Returns the snapshot with a timestep equal
 * to or before the given timestep
 * 
 * Preferred structure: Tree
 */
WorldSnapshot* getClosest(int timestep);

/**
 * Removes all unnecessary snaphots from the structure
 * 
 * Preferred structure: List
 */
void prune(int timestep);
</code></pre></noscript></div>


<p>As you can see by the <strong>Preferred structure</strong> comment, no simple data structure
exists that can efficiently perform all of these operations.  Currently,
however, I only need to use <em>add</em>, <em>purgeAfter</em>, and <em>getClosest</em>, so I have
implemented the structure as a linked list (Dequeue) until I need the additional
functionality.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Real Framework]]></title>
    <link href="http://wellsie1116.github.com/continuum/blog/2011/12/16/a-real-framework/"/>
    <updated>2011-12-16T09:54:00-05:00</updated>
    <id>http://wellsie1116.github.com/continuum/blog/2011/12/16/a-real-framework</id>
    <content type="html"><![CDATA[<p>Two weeks ago, my goal was to finish the basics of my own game framework so I
could get to the fun part of the project: actually making the game.  As I got
into all that I needed to implement before I would be able to get to the actual
game making part, I found the workload a bit overwhelming.  I enjoy using
OpenGL, and using it gives an enormous amount of flexibility, but I could not
justify taking 2-3 times as long using it than using some framework that has
already taken care of all of the technical backend stuff. Enter
<a href="http://www.ogre3d.org">OGRE</a>, an open-source cross-platform rendering engine.</p>

<h2>OGRE</h2>

<p>OGRE is a rendering engine that is independent of any rendering backend.  It can
certainly use OpenGL, but it can just as well use DirectX to render my scenes.
The point is, I only need to setup the scene using meshes, cameras, lights, and
a few other elements, and OGRE does everything that is needed to actually render
the scene.  This greatly simplifies the work that I need to do.  Instead of
figuring out how to store, load, and render my models, OGRE already has the
functionality to do that.  All I have to do is make the models and move them
throughout the world (aka Physics) in a meaningful way.  Furthermore, OGRE has a
library that allows me to define the entire scene (or level) in an external
resource, and the entire scene can be constructed automatically.  This means
that I can use existing programs to generate my levels. For that task, enter
<a href="http://www.blender.org">Blender</a>.</p>

<h2>Blender</h2>

<p>If you have done any 3D modeling in the past, you have probably heard of
Blender because that is exactly what it does.  Why use Blender to design my
levels?  Well, it is free and OGRE has a scene exporter to the level format that
my game will load.  I have also used Blender for level design in the past, so I
am already familiar with it.</p>

<p>After designing my levels, I can simply export them (the level format, the
meshes, and any materials) to the format that my game can understand.  While
loading the level, I create any physics entities that are needed, and kickoff
the physics simulation.</p>

<h2>Looking Forward</h2>

<p>From this point, I have a good list of things that need done.  I need models to
work with, I need some notion of a character that can walk through the levels
and interact with the level, and I need to start implementing the actual point
of the game: messing with time.  For the next few weeks, I will be focusing on
the last two.</p>

<p>Physics engines typically do not allow stepping time backwards, but that is a
problem that I can somewhat easily solve.  If I can track all of the user&#8217;s
input into the game, I can essentially <em>replay</em> the entire scene from start to
finish, simply simulating the input from the user.  This means that no matter
what timestep the world is at, I can compute the state of the world at a earlier
timestep.  Of course, it would be horribly slow to always compute this from the
beginning of the level, so I will have to take snapshots of the world at various
timesteps.  After implementing these concepts, I will be able to completely
control the flow of time in the game.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Things Started]]></title>
    <link href="http://wellsie1116.github.com/continuum/blog/2011/11/30/getting-things-started/"/>
    <updated>2011-11-30T22:45:00-05:00</updated>
    <id>http://wellsie1116.github.com/continuum/blog/2011/11/30/getting-things-started</id>
    <content type="html"><![CDATA[<h2>Game Overview</h2>

<p>My tentative plan for the game is to combine elements from both
<a href="http://braid-game.com">Braid</a> and <a href="http://www.thinkwithportals.com">Portal</a>
with some new game play ideas I come up with.  My main goal with this game is
to explore how a game could bend the ideas of time and space (space-time
<strong>continuum</strong>) to create a unique and innovative game play experience.</p>

<h3>Breaking Time</h3>

<p>At its heart, Continuum will be a puzzle game where the player is presented with
a 3 dimensional world where they need to navigate to the exit.  In order to
reach their goal, they will need to utilize various abilities that they acquire
throughout the game (related to manipulating time and space).  Players will have
no time limit and will have only 1 life, but even though the game will have
elements deadly to players, they will only need 1 life because the players will
have the ability to rewind time.  Even if a player dies, they can simply rewind
time to a state where they were still alive, hopefully making better choices in
the future.  For someone that has not played games such as Braid in the past,
this concept can seem a bit odd.  Consider the following timeline:</p>

<pre><code>            :----------&gt;-------&gt;
            :     0.5     1.0
            :-------:
              -1.0  :
local  -------------:
         1.0

global ------------------------------------------------------------------&gt;
       1    3       2 4        5
</code></pre>

<p>In this graph, <em>global</em> is time as it passes for a passive observer, whereas
<em>local</em> is time as it passes for the player, where they have the ability to
control the flow of time.  In this example, the player plays from timestep 1 to
2, where the player hits an obstacle and dies.  They then rewind time back to
timestep 3, where they continue playing at half of the normal rate of time.
After crossing the difficult obstacle (at timestep 4), they continue playing
until timestep 5, where they solve the puzzle.  To someone watching the game,
the would not see the progression from timestep 2 to 3.  A passive observer
would only see the following sequences of timesteps: 1, 3, 4, 5.</p>

<p>Players will gain additional time manipulation abilities throughout the game.
Consider the following timeline:</p>

<pre><code>                    :----------X
                    :
local  -------------:              :---------X
                    :              :
                    :--------------:
                                   :
                                   :-----------------&gt;

global ------------------------------------------------------------------&gt;
       1            2          3   4         5       6
</code></pre>

<p>In this example, the player has the ability to &#8216;fork&#8217; time, the ability to
duplicate themselves and control both timelines.  How is this useful?  Consider
a simple example.  In a level, there is a door which must be opened by a switch
that it takes 5 seconds to walk to.  The switch, however, will only keep the
door open for 3 seconds.  To solve the puzzle, the player can set a marker point
(timesteps 2 and 4 in the example above), go and press the button, and then jump
back to the marker point, and simply walk through the door when their double
presses the button.</p>

<p>In the example above, the player moves through time normally from step 1 to 2,
at which point they set a fork marker.  They then move through the top branch to
step 3, where they instantaneously jump back to step 2 and then move through the
lower branch to step 4.  During this time, they could see their &#8216;double&#8217; moving
through the level doing whatever they did.  This example has a second fork in
time, and it functions the same as the first.</p>

<h3>Breaking Space</h3>

<p>Time permitting, I would like to also incorporate space manipulation elements
similar to the popular game Portal, which involves the player specifying two
arbitrary points in the level that they can instantaneously jump from one point
to the other.  I plan on basing the game in the same universe as Portal, and it
would be fun to incorporate aspects of other games in that universe.</p>

<h2>Choosing a Framework</h2>

<p>While the focus of this project is on creating a full featured game, I feel like
I will be unable to use any existing full-package frameworks to do the job
mostly because this game breaks conventional ideas about first person shooters.
Most game engines don&#8217;t support forking time, let alone introducing portals.
One game engine that I did look into was Source, the same game engine that was
used to make Portal and Portal 2.  It is possible to write mods for those games,
but, unfortunately, Valve has not yet released the SDK for Portal 2, which is my
target platform if I would make a mod to the game.  Instead, I plan on using SDL
to host the application, OpenGL for graphics rendering, OpenAL for 3D audio, ODE
for my physics engine, and a blend of C and Python for the implementation language.</p>
]]></content>
  </entry>
  
</feed>
